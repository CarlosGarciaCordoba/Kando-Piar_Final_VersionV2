-- =============================================
-- SISTEMA PIAR - BASE DE DATOS INICIAL
-- Sistema de Login y Estructura Básica
-- =============================================

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- =============================================
-- TABLA DE COLEGIOS
-- =============================================
CREATE TABLE colegios (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    codigo_institucion VARCHAR(10) UNIQUE NOT NULL,
    nombre VARCHAR(200) NOT NULL,
    estado BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- =============================================
-- TABLA DE SEDES
-- =============================================
CREATE TABLE sedes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    colegio_id UUID REFERENCES colegios(id) ON DELETE CASCADE,
    codigo_sede VARCHAR(5) NOT NULL,
    nombre VARCHAR(200) NOT NULL,
    codigo_completo VARCHAR(15) UNIQUE NOT NULL, -- Código institución + sede
    estado BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(colegio_id, codigo_sede)
);

-- =============================================
-- TABLA DE GRADOS
-- =============================================
CREATE TABLE grados (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    sede_id UUID REFERENCES sedes(id) ON DELETE CASCADE,
    grado VARCHAR(10) NOT NULL, -- 1, 2, 3, ..., 11
    nivel VARCHAR(20) NOT NULL, -- Primaria, Secundaria, Media
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- =============================================
-- TABLA DE USUARIOS
-- =============================================
CREATE TABLE usuarios (
    cedula VARCHAR(20) PRIMARY KEY,
    codigo_usuario VARCHAR(3) UNIQUE NOT NULL,
    nombres VARCHAR(100) NOT NULL,
    apellidos VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    telefono VARCHAR(20),
    password_hash VARCHAR(255) NOT NULL,
    codigo_institucion VARCHAR(15) NOT NULL,
    estado BOOLEAN DEFAULT true,
    debe_cambiar_password BOOLEAN DEFAULT true,
    ultimo_acceso TIMESTAMP,
    intentos_fallidos INTEGER DEFAULT 0,
    bloqueado_hasta TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (codigo_institucion) REFERENCES sedes(codigo_completo)
);

-- =============================================
-- FUNCIONES
-- =============================================

-- Función para generar código de usuario único
CREATE OR REPLACE FUNCTION generar_codigo_usuario(p_nombres TEXT, p_apellidos TEXT)
RETURNS VARCHAR(3) AS $$
DECLARE
    codigo_base VARCHAR(3);
    codigo_final VARCHAR(3);
    contador INTEGER := 1;
    primera_inicial CHAR(1);
    segunda_inicial CHAR(1);
BEGIN
    primera_inicial := UPPER(SUBSTRING(TRIM(p_nombres), 1, 1));
    segunda_inicial := UPPER(SUBSTRING(TRIM(p_apellidos), 1, 1));
    codigo_base := primera_inicial || segunda_inicial;
    
    WHILE contador <= 99 LOOP
        IF contador <= 9 THEN
            codigo_final := codigo_base || contador::TEXT;
        ELSE 
            codigo_final := codigo_base || CHR(65 + ((contador - 10) % 26));
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM usuarios WHERE codigo_usuario = codigo_final) THEN
            RETURN codigo_final;
        END IF;
        
        contador := contador + 1;
    END LOOP;
    
    RAISE EXCEPTION 'No se pudo generar un código único para: % %', p_nombres, p_apellidos;
END;
$$ LANGUAGE plpgsql;

-- Función para validar contraseña segura
CREATE OR REPLACE FUNCTION validar_password_segura(password TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    IF LENGTH(password) < 10 THEN
        RETURN FALSE;
    END IF;
    
    IF (SELECT LENGTH(REGEXP_REPLACE(password, '[^0-9]', '', 'g'))) < 3 THEN
        RETURN FALSE;
    END IF;
    
    IF (SELECT LENGTH(REGEXP_REPLACE(password, '[^A-Z]', '', 'g'))) < 2 THEN
        RETURN FALSE;
    END IF;
    
    IF (SELECT LENGTH(REGEXP_REPLACE(password, '[^a-z]', '', 'g'))) < 2 THEN
        RETURN FALSE;
    END IF;
    
    IF (SELECT LENGTH(REGEXP_REPLACE(password, '[A-Za-z0-9]', '', 'g'))) < 2 THEN
        RETURN FALSE;
    END IF;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- TRIGGERS
-- =============================================

-- Trigger para generar código de usuario
CREATE OR REPLACE FUNCTION trigger_generar_codigo_usuario()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo_usuario IS NULL OR NEW.codigo_usuario = '' THEN
        NEW.codigo_usuario := generar_codigo_usuario(NEW.nombres, NEW.apellidos);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER usuarios_generar_codigo
    BEFORE INSERT ON usuarios
    FOR EACH ROW
    EXECUTE FUNCTION trigger_generar_codigo_usuario();

-- Trigger para actualizar timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_usuarios_updated_at
    BEFORE UPDATE ON usuarios
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- ÍNDICES
-- =============================================
CREATE INDEX idx_usuarios_codigo_institucion ON usuarios(codigo_institucion);
CREATE INDEX idx_usuarios_estado ON usuarios(estado);
CREATE INDEX idx_usuarios_email ON usuarios(email);
CREATE INDEX idx_sedes_codigo_completo ON sedes(codigo_completo);
CREATE INDEX idx_colegios_codigo_institucion ON colegios(codigo_institucion);
CREATE INDEX idx_grados_sede ON grados(sede_id, grado);

-- =============================================
-- VISTAS
-- =============================================
CREATE VIEW vista_usuarios_completa AS
SELECT 
    u.cedula,
    u.codigo_usuario,
    u.nombres,
    u.apellidos,
    u.email,
    u.telefono,
    u.codigo_institucion,
    c.nombre AS colegio_nombre,
    s.nombre AS sede_nombre,
    u.estado,
    u.ultimo_acceso,
    u.debe_cambiar_password,
    u.created_at
FROM usuarios u
JOIN sedes s ON u.codigo_institucion = s.codigo_completo
JOIN colegios c ON s.colegio_id = c.id;

-- =============================================
-- RESTRICCIONES
-- =============================================
ALTER TABLE usuarios 
ADD CONSTRAINT check_email_format 
CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

ALTER TABLE usuarios 
ADD CONSTRAINT check_telefono_format 
CHECK (telefono ~ '^[0-9]{10}$');

ALTER TABLE usuarios 
ADD CONSTRAINT check_codigo_usuario_format 
CHECK (codigo_usuario ~ '^[A-Z0-9]{3}$');

-- =============================================
-- TABLA ASIGNATURAS
-- Parametrización para las asignaturas académicas del sistema educativo
-- =============================================
CREATE TABLE asignaturas (
    id_asignatura INTEGER PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL UNIQUE,
    descripcion VARCHAR(200),
    estado BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- =============================================
-- ÍNDICES PARA TABLA ASIGNATURAS
-- =============================================
CREATE INDEX idx_asignaturas_nombre ON asignaturas(nombre);

-- =============================================
-- TRIGGER PARA TABLA ASIGNATURAS
-- =============================================
CREATE TRIGGER update_asignaturas_updated_at 
    BEFORE UPDATE ON asignaturas
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- DATOS INICIALES - ASIGNATURAS
-- =============================================
INSERT INTO asignaturas (id_asignatura, nombre, descripcion, estado) VALUES 
(1, 'Lengua Castellana', 'Asignatura de lengua y literatura castellana', true),
(2, 'Matemáticas', 'Asignatura de matemáticas y álgebra', true),
(3, 'Ciencias Naturales', 'Asignatura de ciencias naturales y biología', true),
(4, 'Ciencias Sociales', 'Asignatura de ciencias sociales e historia', true),
(5, 'Educación Artística', 'Asignatura de educación artística y cultural', true),
(6, 'Educación Física, Recreación y Deporte', 'Asignatura de educación física y deportes', true),
(7, 'Educación Religiosa o Ética y Valores', 'Asignatura de religión, ética y valores', true),
(8, 'Filosofía', 'Asignatura de filosofía', true),
(9, 'Química', 'Asignatura de química', true),
(10, 'Física', 'Asignatura de física', true);

-- =============================================
-- CONSULTAS ÚTILES PARA ASIGNATURAS
-- =============================================
-- Obtener todas las asignaturas activas:
-- SELECT * FROM asignaturas WHERE estado = true ORDER BY nombre;

-- Buscar asignatura por nombre:
-- SELECT * FROM asignaturas WHERE nombre ILIKE '%matematicas%';

-- Contar asignaturas activas:
-- SELECT COUNT(*) FROM asignaturas WHERE estado = true;

-- =============================================
-- TABLA DE GRADOS PIAR
-- Fecha de creación: 14 de octubre de 2025
-- Propósito: Grados académicos para el sistema PIAR
-- =============================================
CREATE TABLE IF NOT EXISTS grados_piar (
    id_grado SERIAL PRIMARY KEY,
    nombre VARCHAR(50) NOT NULL UNIQUE,
    descripcion TEXT,
    nivel_educativo VARCHAR(20) NOT NULL CHECK (nivel_educativo IN ('preescolar', 'basica', 'media')),
    orden_grado INTEGER NOT NULL,
    estado BOOLEAN DEFAULT TRUE,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insertar los grados académicos
INSERT INTO grados_piar (id_grado, nombre, descripcion, nivel_educativo, orden_grado) VALUES
-- Preescolar
(1, 'Pre-Jardín', 'Nivel de educación inicial para niños de 3 años', 'preescolar', 1),
(2, 'Jardín', 'Nivel de educación inicial para niños de 4 años', 'preescolar', 2),
(3, 'Transición', 'Nivel de educación inicial para niños de 5 años', 'preescolar', 3),
-- Básica (Primaria y Secundaria unificadas)
(4, '1°', 'Primer grado de educación básica', 'basica', 4),
(5, '2°', 'Segundo grado de educación básica', 'basica', 5),
(6, '3°', 'Tercer grado de educación básica', 'basica', 6),
(7, '4°', 'Cuarto grado de educación básica', 'basica', 7),
(8, '5°', 'Quinto grado de educación básica', 'basica', 8),
(9, '6°', 'Sexto grado de educación básica', 'basica', 9),
(10, '7°', 'Séptimo grado de educación básica', 'basica', 10),
(11, '8°', 'Octavo grado de educación básica', 'basica', 11),
(12, '9°', 'Noveno grado de educación básica', 'basica', 12),
-- Media
(13, '10°', 'Décimo grado de educación media', 'media', 13),
(14, '11°', 'Undécimo grado de educación media', 'media', 14);

-- Crear índices para optimizar consultas
CREATE INDEX idx_grados_piar_nivel_educativo ON grados_piar(nivel_educativo);
CREATE INDEX idx_grados_piar_orden_grado ON grados_piar(orden_grado);
CREATE INDEX idx_grados_piar_estado ON grados_piar(estado);

-- =============================================
-- CONSULTAS ÚTILES PARA GRADOS PIAR
-- =============================================
-- Obtener todos los grados activos ordenados:
-- SELECT * FROM grados_piar WHERE estado = true ORDER BY orden_grado;

-- Obtener grados por nivel educativo:
-- SELECT * FROM grados_piar WHERE nivel_educativo = 'preescolar' AND estado = true ORDER BY orden_grado;
-- SELECT * FROM grados_piar WHERE nivel_educativo = 'basica' AND estado = true ORDER BY orden_grado;
-- SELECT * FROM grados_piar WHERE nivel_educativo = 'media' AND estado = true ORDER BY orden_grado;

-- Contar grados por nivel:
-- SELECT nivel_educativo, COUNT(*) as cantidad FROM grados_piar WHERE estado = true GROUP BY nivel_educativo ORDER BY MIN(orden_grado);

-- Obtener resumen de grados por nivel:
-- SELECT 
--     nivel_educativo,
--     COUNT(*) as cantidad_grados,
--     STRING_AGG(nombre, ', ' ORDER BY orden_grado) as grados
-- FROM grados_piar 
-- WHERE estado = true
-- GROUP BY nivel_educativo
-- ORDER BY MIN(orden_grado);
